---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

## Двоичные деревья поиска (Binary Search Tree)

<!-- #region -->
### Цель работы

изучение структуры данных «Двоичное дерево поиска», а также основных операций над ним.


### Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 05.12.2024

Жесткий дедлайн (5 баллов): 19.12.2024
<!-- #endregion -->

### Теоретические сведения

<!-- #region -->
Дерево — это совокупность элементов, называемых узлами (при этом один из них определен как корень), и отношений (родительский–дочерний), образующих иерархическую структуру узлов. Узлы могут являться величинами любого простого или структурированного типа, за исключением файлового. Узлы, которые не имеют ни одного последующего узла, называются листьями.

В двоичном (бинарном) дереве каждый узел может быть связан не более чем с двумя другими узлами. Рекурсивно двоичное дерево определяется так: двоичное дерево бывает либо пустым (не содержит ни одного узла), либо содержит узел, называемый корнем, а также два независимых поддерева — левое поддерево и правое поддерево.

Для обработки дерева достаточно знать адрес корневой вершины.

Высотой поддерева будем считать максимальную длину цепи $y_1, ...$, его вершин такую, что $y_{i+1}$ – потомок $y_i$ для всех i.
Высота пустого дерева равна нулю, высота дерева из одного корня – единице.

Степенью вершины в дереве называется количество дуг, которое из нее выходит.
Степень дерева равна максимальной степени вершины, входящей в дерево.
При этом листьями в дереве являются вершины, имеющие степень нуль.

Двоичное дерево поиска может быть либо пустым, либо оно обладает таким свойством, что корневой элемент имеет большее значение узла, чем любой элемент в левом поддереве, и меньшее или равное, чем элементы в правом поддереве.
Указанное свойство называется характеристическим свойством двоичного дерева
поиска и выполняется для любого узла такого дерева, включая корень. Важное
свойство такого дерева: все элементы его различны. Название двоичные деревья
поиска получили по той причине, что скорость поиска в них примерно такая же, что и в отсортированных массивах: $O(n) = C \cdot \log_2{n}$ (в худшем случае O(n) = n).


#### Основные операции

Большинство операций над деревьями носят рекурсивный характер, поскольку дерево само по себе является рекурсивной структурой данных.

#### Поиск элементов в дереве
Алгоритм поиска в двоичном дереве очень прост:

Начиная с корневой вершины для каждого текущего поддерева надо выполнить следующие шаги:
- сравнить ключ вершины с заданным значением x;
- если заданное значение меньше ключа вершины, перейти к левому поддереву, иначе перейти к правому поддереву.

Поиск прекращается при выполнении одного из двух условий:
- либо, если найден искомый элемент;
- либо, если надо продолжать поиск в пустом поддереве, что является признаком отсутствия искомого элемента.

#### Добавление элемента в дерево

Алгоритм добавления включает следующие шаги:
- выделение памяти для новой вершины;
- формирование информационной составляющей;
- формирование двух пустых ссылочных полей на будущих потомков;
- формирование в родительской вершине левого или правого ссылочного поля – адреса новой вершины.

#### Удаление элемента из дерева

Теперь рассмотрим удаление вершины из двоичного дерева.
По сравнению с добавлением удаление реализуется более сложным алгоритмом, поскольку добавляемая вершина всегда является терминальной, а удаляться может любая, в том числе и нетерминальная. При этом может возникать несколько различных
ситуаций.

Рассмотрим фрагмент двоичного с целыми ключами.

**Ситуация 1.** Удаляемая вершина не имеет ни одного потомка, т.е. является терминальной. Удаление реализуется очень легко: обнулением соответствующего указателя у родителя.

**Ситуация 2.** Удаляемая вершина имеет только одного потомка. В этом случае удаляемая вершина вместе со своим потомком и родителем образуют фрагмент линейного списка. Удаление реализуется простым изменением указателя у родительского элемента.

**Ситуация 3.** Пусть удаляемая вершина имеет двух потомков. Этот случай наиболее сложен, поскольку нельзя просто в родительской вершине изменить соответствующее ссылочное поле на адрес одного из потомков удаляемой вершины.
Это может нарушить структуру дерева поиска. Существует специальное правило для определения вершины, которая должна
заменить удаляемую. Это правило состоит из двух взаимоисключающих действий:
 - либо войти в левое поддерево удаляемой вершины и в этом поддереве спуститься как можно глубже, придерживаясь только правых потомков; это
позволяет найти в дереве ближайшую меньшую вершину;
 - либо войти в правое поддерево удаляемой вершины и спуститься в нем как можно глубже, придерживаясь только левых потомков; это позволяет найти ближайшую большую вершину.

#### Обход дерева.

**Обход в прямом направлении**:
- обработать корневую вершину текущего поддерева;
- перейти к обработке левого поддерева таким же образом;
- обработать правое поддерево таким же образом.

**Симметричный обход**:
- рекурсивно обработать левое поддерево текущего поддерева;
- обработать вершину текущего поддерева;
- рекурсивно обработать правое поддерево.

**Обход в обратном направлении**:
- рекурсивно обработать левое поддерево текущего поддерева;
- рекурсивно обработать правое поддерево;
- затем – вершину текущего поддерева.
<!-- #endregion -->

### Задания на лабораторную работу

<!-- #region -->
**1.** Реализовать программу, выполняющую стандартный набор операций над  двоичным деревом поиска:
- формирование бинарного дерева;
- обход (прямой, симметричный, обратный) бинарного дерева;
- удаление заданной вершины из бинарного дерева;
- поиск заданной вершины в бинарном дереве (по значению);
- печать бинарного дерева на экран;
- проверка пустоты бинарного дерева;
- определение высоты бинарного дерева.


Требования:
 - дерево должно быть реализовано в виде класса;
 - каждая операция должна быть реализована как метод класса;
 - добавлению/удалению должна предшествовать проверка возможности выполнения этих операций;

**2.** Реализовать самобалансирующееся дерево (AVL-дерево для четных вариантов, красно-черное дерево для нечетных вариантов)

**3.** Реализовать индивидуальные задание.
<!-- #endregion -->

### Индивидуальные задания

**Задание 1.**

1. Найти сумму элементов бинарного дерева.
2. Найти вершины, у которых количество потомков в левом поддереве не равно количеству потомков в правом поддереве.
3. Найти вершины, для которых высота левого поддерева не равна высоте правого поддерева.
4. Вернуть поддерево вершиной которого является максимальный элемент дерева
5. Найти максимальный элемент бинарного дерева.
6. Написать функцию, которая определяет, есть ли в бинарном дереве хотя бы два одинаковых элемента.
7. Написать функцию, определяющую количество отрицательных элементов бинарного дерева.
8. Написать функцию, которая определяет, является ли бинарное дерево симметричным.
9. Написать функцию, которая определяет, является ли бинарное дерево деревом поиска.
10. Вывести все листья дерева в порядке возрастания.
11. Пусть имеется бинарное дерево T. Сформировать два дерева из отрицательных и неотрицательных элементов дерева T.
12. Вывести все листья дерева поиска в порядке возрастания.
13. Найти последний номер из всех уровней бинарного дерева, на которых есть положительные элементы.
14. На каждом уровне бинарного дерева найти максимальный элемент.
15. На каждом уровне дерева найти количество внутренних вершин и количество листьев.
16. Найти суммы элементов всех нечетных уровней.
17. Найти произведения элементов всех четных уровней.
18. Объединить два бинарных дерева поиска
19. Пусть имеется бинарное дерево T. Сформировать два дерева из четных и нечетных элементов дерева T.
20. Написать функцию, определяющую количество элементов бинарного дерева кратных трем.
21. Найти произведение элементов бинарного дерева.
22. Найти среднее арифметическое элементов бинарного дерева.
23. На каждом уровне бинарного дерева найти минимальный элемент.
24. Вернуть поддерево вершиной которого является минимальный элемент дерева
25. Найти сумму элементов бинарного дерева кратных трем
26. Вернуть поддерево вершиной которого является максимальный элемент дерева
27. Найти медиану элементов бинарного дерева.


### Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


### Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.

4. Выводы по лабораторной работе.

5. Ответы на контрольные вопросы.


### Важные замечания


<!-- #region jp-MarkdownHeadingCollapsed=true -->
### Контрольные вопросы

1. С чем связана популярность использования деревьев в программировании?
2. Можно ли список отнести к деревьям? Ответ обоснуйте.
3. Какие данные содержат адресные поля элемента бинарного дерева?
4. Что такое дерево, двоичное дерево, поддерево?
5. Как рекурсивно определяется дерево?
6. Какие основные понятия связываются с деревьями?
7. Какие основные операции характерны при использовании деревьев?
8. Как программно реализуется алгоритм операции обхода дерева?
9.  Как программно реализуется алгоритм операции добавления элемента в дерево?
10. Как программно реализуется алгоритм операции удаления элемента из дерева?
11. Как программно реализуется  алгоритм операции поиска элемента в дереве?
12. Что такое самобалансирующееся дерево?
13. Как определяется количество узлов в самобалансирующемся дереве?
14. Как происходит добавление элемента в самобалансирующееся дерево?
15. Как происходит удаление элемента из самобалансирующееся дерева?
16. Особенности красно-черных деревьев.
17. Особенности АВЛ деревьев.
<!-- #endregion -->

### Список литературы

1. Кнут, Д. Э. Искусство программирования: пер. с англ. / Д. Э. Кнут . - 3-е изд. - Москва : Вильямс, 2007. - Т. 1 : Основные алгоритмы, 2007. - 720 с. : ил.. - Прил.: с. 683-691. - Предм.-имен. указ.: с. 692-712. - ISBN 5-8459-0080-8.
2. Кнут, Д. Э. Искусство программирования / Д. Э. Кнут ; под общ. ред. Ю. В. Козаченко. - 2-е изд. - М. : Вильямс, 2009. - (Классический труд : Исправленное и дополненное издание). Т. 3 : Сортировка и поиск. - , 2009. - 823 с. : ил.. - Прил.: с. 794-803. - . - Предм.-имен. указ.: с. 804-822 - ISBN 978-5-8459-0082-1.
3. Кормен, Т. Алгоритмы: Построение и анализ / Т. Кормен, Ч. Лейхерсон, Р. Риверст. – М.: МЦМНО, 2002.
4. Давыдов, В. Г.  Программирование и основы алгоритмизации: учеб.
пособие для вузов / В. Г. Давыдов. - М. : Высш. шк., 2003. - 447 с. : ил - ISBN 5-06-
004432-7.
5. Ахо, А. Построение и анализ вычислительных алгоритмов / А. Ахо, Дж. Хопкрофт, Дж. Ульмен. – М.: Мир, 1989. – 369с.
6. Никлаус Вирт Алгоритмы и структуры данных. – Санкт-Петербург: «Невский диалект», 2001.

```python

```
