---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Эмпирический анализ временной сложности алгоритмов


Лабораторная работа № 1. 

Мягкий дедлайн (10 баллов): 03.10.2024

Жесткий дедлайн (5 баллов): 17.10.2024


## Цель работы

Эмпирический анализ временной сложности алгоритмов.


## Краткие теоретические сведения

Временная сложность – это характеристика алгоритма, призванная давать представление о количестве времени, требуемом для работы алгоритма на определенном объеме данных. 
Оценка временной сложности алгоритма [1, 2, 4] осуществляется путем подсчета количества элементарных операций (сложений, умножений и т.д.), выполняемых алгоритмом для заданного объема данных. 
При этом предполагается, что выполнение каждой элементарной операции требует фиксированного количества времени.
В связи с тем, что время работы алгоритма может быть различно для данных разного объема, временную сложность принято определять
с помощью функции $T$ , отражающей зависимость времени работы алгоритма $T(n)$ от объема $n$ входных данных. 
При этом особое внимание уделается асимптотическому поведению $T(n)$ при $n \to \infty$. 
При анализе асимптотического поведения $T(n)$ естественным образом учитываются только слагаемые самого высокого порядка, причем без внимания к их константным множителям. 
Поэтому чаще всего временную сложность $T(n)$ записывают в формате $O$-большое.
В таких терминах утверждение о том, что временная сложность некоторого алгоритма равна $O(t(n))$, где $t(n) > 0$ – некоторая функция, означает, что с увеличением объема $n$ входных данных время работы алгоритма будет асимптотически возрастать не быстрее, чем $C \cdot t(n)$ с некоторой фиксированной константой $C > 0$. 
Например, $O(n^2)$ – временная сложность алгоритма сортировки пузырьком элементов действительного вектора $v$ размерности $n$, а $O(n3)$ – временная сложность алгоритма обычного умножения двух матриц размера $n × n$. 
В [3] приводятся временные сложности многих стандартных алгоритмов.

Оценка временной сложности алгоритмов не всегда проста; для некоторых алгоритмов временные сложности по-прежнему неизвестны. 
(Это замечание, конечно, не касается алгоритмов, рассматриваемых в данной
лабораторной работе, – их временные сложности могут быть оценены [1, 2, 4].) 

Для того, чтобы все-таки получить представление о временной сложности алгоритма, можно применять эмпирический подход [1].
Он состоит в проведении серии замеров времени работы алгоритма при изменении объема входных данных. 
Например, для алгоритма, принимающего на вход векторы размерности $n$, можно замерять машинное время
его работы при $n$, скажем, от $1$ до $10^5$ с шагом $10$. 
При этом предполагается, что алгоритм запускается в одинаковых условиях, в частности, на одном и том же компьютере, не выполняющем каких-либо дополнительных вычислительных процессов, способных существенно повлиять на время работы рассматриваемого алгоритма. 
Наличие одинаковых условий при каждом замере принципиально важно для качества полученных результатов. 

Стоит отметить, что и при использовании одного и того же компьютера достичь этого не всегда удается – влияние на результат могут оказывать многочисленные факторы, в том числе фоновые процессы системы. 
Разумный компромисс в такой ситуации – усреднять замеры времени по нескольким запускам для одного и того же объема данных.
На рисунках 1 и 2 приведены примеры эмпирического исследования временной сложности алгоритма, реализующего функцию $f(v) = 1$, и алгоритма сортировки пузырьком элементов вектора $v$ при разной размерности входного вектора $v$. 
Легко видеть, что эмпирически полученные кривые могут допускать даже значительные отклонения от теоретических кривых, но в среднем вполне очевидно соответствие между экспериментом и теорией.



## Задания

Для $n$ от 1 до $10^5 \cdot N$ c шагом $100 \cdot N$, где $N = (20 - \text{номер студента в списке группе})$, произведите для пяти запусков замер среднего машинного времени исполнения программ, реализующих нижеуказанные алгоритмы и функции. 

Изобразите на графике полученные данные, отражающие зависимость среднего времени исполнения от $n$. 
Проведите теоретический анализ временной сложности рассматриваемых алгоритмов и сравните эмпирическую и теоретическую временные сложности.

<!-- #region -->
## Задание 1

Сгенерируйте $n$-мерный случайный вектор $v = [v_1, v_2, ..., v_n]$ с
неотрицательными элементами. 

Для полученного вектора $v$ осуществите подсчет функций и реализацию алгоритмов:


| №  | Оценивание | Функция | Вариант | Примечание |
|:--|:----------:|:-------|:-------|:----------:|
| 1.1.  доступ к элементу по индексу           | 2 балла | $f_1(i) = v(i)$                            | 2, 4, 5, 7, 9, 11, 13, 15, 16, 18 ||
| 1.2. сумма элементов                         | 2 балла | $f_2(v) = \sum\limits_{k=1}^{n} {v_k}$     | 1, 3, 6, 8, 10, 12, 14, 17? 19||
| 1.3  произведение элементов                  | 2 балла | $f_3(v) = \prod\limits_{k=1}^{n} {v_k}$    | 1, 2, 5, 6, 7, 10, 11, 14, 15, 16? 19 ||
| 1.4. вычисление полинома методом Горнера [2] | 2 балла | $f_4(v) = v_1 + x (v_2 + x(v_3+ \ldots))$, | 2, 4, 6, 9, 10, 11, 13, 16, 17, 18| |
| 1.5. поиск максимума простым перебором       | 2 балла | $f_5(v) = \max(v)$                         | 1, 3, 4, 7, 8, 9, 12, 14, 16, 18 ||
| 1.6. поиск минимума простым перебором        | 2 балла | $f_6(v) = \min(v)$                         | 3, 5, 6, 8, 10, 13, 15, 17? 19 ||
| 1.7. среднее арифметическое                  | 2 балла | $f_7(v) = \cfrac{1}{n} \cdot \sum\limits_{k=1}^{n} {v_k}$   | 1, 2, 4, 9, 11, 12, 13, 14, 15, 16, 18 ||
| 1.8. среднее гармоническое                   | 2 балла | $f_8(v) = \cfrac{n}{\sum\limits_{k=1}^{n} {\frac{1}{v_k}}}  $ | 3, 5, 7, 8, 12, 14, 17? 19| |

<!-- #endregion -->

## Задание 2

(2 балла)

Сгенерируйте случайные матрицы $A$ и $B$ размером $n × n$ с неотрицательными элементами. 

Найдите обычное матричное произведение матриц $A$ и $B$.


## Примечания

Для замера времени работы функции и построения графиков, можно воспользоваться примером, приведенным здесь:

[./example/usage_time_example.md](./example/usage_time_example.md)


## Вопросы для самоконтроля

1. Обозначим количество вершин в графе через $n$. 
Что означает выражение $O(n)$, описывающее временную сложность некоторого алгоритма на графах?

2. С чем связана необходимость усреднять по нескольким запускам замеры времени работы алгоритма при эмпирическом анализе временной сложности алгоритма?


## Список литературы

1. Левитин, А.В. Алгоритмы: введение в разработку и анализ. М.: Из-
дательский дом Вильямс, 2006

2. Макконелл Дж. Анализ алгоритмов. Вводный курс. М.: Техносфера, 2002.

3. Big-O complexities of common algorithms used in Computer Science
https://blogs.longwin.com.tw/wordpress/201608-bigoposter.pdf

4. Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C. Introduction to Algorithms. Third Edition. The MIT Press, 2009.
